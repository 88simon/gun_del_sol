; ============================================================================
; Solscan Hotkey Script
; ============================================================================
; Description: Click side mouse button over a Solana address to open Solscan
; Author: Generated by Claude Code
; Version: 3.0 (AutoHotkey v2) - Wheel Menu Edition
;
; Recent changes:
; - F13 now opens radial wheel menu with all actions
; - Mouse gesture or keyboard (1-6) selection
; - Visual feedback with real-time hover states
; - All existing hotkeys still work as direct shortcuts
; ============================================================================

#Requires AutoHotkey v2.0
#SingleInstance Force
SetWorkingDir A_ScriptDir
SendMode "Input"
CoordMode "Mouse", "Screen"

; ============================================================================
; GDI+ helper functions for wheel menu rendering
; ============================================================================
; IMPORTANT: These must be defined BEFORE InitGdip() is called below

Gdip_Startup() {
    static loaded := false
    if (!loaded)
        DllCall("LoadLibrary", "str", "gdiplus.dll", "Ptr")
    si := Buffer(16, 0)
    NumPut("UInt", 1, si, 0)                    ; GdiplusVersion
    NumPut("UInt", 0, si, 4)                    ; DebugEventCallback
    NumPut("UInt", 0, si, 8)                    ; SuppressBackgroundThread
    NumPut("UInt", 0, si, 12)                   ; SuppressExternalCodecs
    token := 0
    if (DllCall("gdiplus\GdiplusStartup", "Ptr*", &token, "Ptr", si, "Ptr", 0, "UInt"))
        return 0
    loaded := true
    return token
}

Gdip_Shutdown(token) {
    if (token)
        DllCall("gdiplus\GdiplusShutdown", "Ptr", token)
}

Gdip_GraphicsFromHDC(hdc) {
    graphics := 0
    if (DllCall("gdiplus\GdipCreateFromHDC", "Ptr", hdc, "Ptr*", &graphics, "UInt"))
        return 0
    return graphics
}

Gdip_DeleteGraphics(graphics) {
    if (graphics)
        DllCall("gdiplus\GdipDeleteGraphics", "Ptr", graphics)
}

Gdip_SetSmoothingMode(graphics, mode) {
    return DllCall("gdiplus\GdipSetSmoothingMode", "Ptr", graphics, "Int", mode, "UInt")
}

Gdip_GraphicsClear(graphics, argb) {
    return DllCall("gdiplus\GdipGraphicsClear", "Ptr", graphics, "UInt", argb, "UInt")
}

Gdip_BrushCreateSolid(argb) {
    brush := 0
    if (DllCall("gdiplus\GdipCreateSolidFill", "UInt", argb, "Ptr*", &brush, "UInt"))
        return 0
    return brush
}

Gdip_DeleteBrush(brush) {
    if (brush)
        DllCall("gdiplus\GdipDeleteBrush", "Ptr", brush)
}

Gdip_FillPie(graphics, brush, x, y, w, h, startAngle, sweepAngle) {
    return DllCall("gdiplus\GdipFillPie", "Ptr", graphics, "Ptr", brush
        , "Float", x, "Float", y, "Float", w, "Float", h
        , "Float", startAngle, "Float", sweepAngle, "UInt")
}

Gdip_FillEllipse(graphics, brush, x, y, w, h) {
    return DllCall("gdiplus\GdipFillEllipse", "Ptr", graphics, "Ptr", brush
        , "Float", x, "Float", y, "Float", w, "Float", h, "UInt")
}

CreateDIBSection(width, height) {
    hdc := DllCall("user32\GetDC", "Ptr", 0, "Ptr")
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)                   ; biSize
    NumPut("Int", width, bi, 4)                 ; biWidth
    NumPut("Int", -height, bi, 8)               ; biHeight (top-down)
    NumPut("UShort", 1, bi, 12)                 ; biPlanes
    NumPut("UShort", 32, bi, 14)                ; biBitCount
    NumPut("UInt", 0, bi, 16)                   ; biCompression (BI_RGB)
    pvBits := 0
    hbm := DllCall("gdi32\CreateDIBSection", "Ptr", hdc, "Ptr", bi, "UInt", 0
        , "Ptr*", &pvBits, "Ptr", 0, "UInt", 0, "Ptr")
    DllCall("user32\ReleaseDC", "Ptr", 0, "Ptr", hdc)
    return hbm
}

CreateCompatibleDC() {
    return DllCall("gdi32\CreateCompatibleDC", "Ptr", 0, "Ptr")
}

SelectObject(hdc, object) {
    return DllCall("gdi32\SelectObject", "Ptr", hdc, "Ptr", object, "Ptr")
}

DeleteDC(hdc) {
    if (hdc)
        DllCall("gdi32\DeleteDC", "Ptr", hdc)
}

DeleteObject(hObj) {
    if (hObj)
        DllCall("gdi32\DeleteObject", "Ptr", hObj)
}

UpdateLayeredWindow(hwnd, hdc, x, y, width, height) {
    size := Buffer(8, 0)
    NumPut("Int", width, size, 0)
    NumPut("Int", height, size, 4)

    ptSrc := Buffer(8, 0)
    ptDest := Buffer(8, 0)
    NumPut("Int", x, ptDest, 0)
    NumPut("Int", y, ptDest, 4)

    blend := Buffer(4, 0)
    NumPut("UChar", 0, blend, 0)                ; AC_SRC_OVER
    NumPut("UChar", 0, blend, 1)                ; BlendFlags
    NumPut("UChar", 255, blend, 2)              ; SourceConstantAlpha
    NumPut("UChar", 1, blend, 3)                ; AC_SRC_ALPHA

    return DllCall("user32\UpdateLayeredWindow", "Ptr", hwnd, "Ptr", 0
        , "Ptr", ptDest, "Ptr", size, "Ptr", hdc, "Ptr", ptSrc
        , "UInt", 0, "Ptr", blend, "UInt", 0x02)
}

; Configuration
NOTIFICATION_DURATION := 2000  ; milliseconds
SELECTION_DELAY := 100         ; delay after selection before copy
LOCAL_SERVER_URL := "http://localhost:5001/register"  ; Telegram monitor service

; GDI+ initialization
global g_GdipToken := 0

InitGdip() {
    global g_GdipToken
    if !g_GdipToken {
        g_GdipToken := Gdip_Startup()
        if (!g_GdipToken) {
            MsgBox "GDI+ failed to initialize! Token: " . g_GdipToken
            ExitApp
        }
        OnExit(ShutdownGdip)
    }
}

ShutdownGdip(*) {
    global g_GdipToken
    if g_GdipToken {
        Gdip_Shutdown(g_GdipToken)
        g_GdipToken := 0
    }
}

; Initialize GDI+ on startup
InitGdip()

; Legacy global variables (kept for F14 backward compatibility)
global currentMainAddress := ""
global excludedAddressesList := []

; ============================================================================
; MAIN HOTKEY: F14 (mapped from your mouse button in G HUB)
; ============================================================================
; Opens Solana address in Solscan with filters
; Hover over address + click the button you mapped to F14
; ============================================================================

F14::HandleSolscanLookup()

; ============================================================================
; WHEEL MENU HOTKEY: F13 (mapped from your mouse button in G HUB)
; ============================================================================
; Opens radial wheel menu with all available actions
; Click the button you mapped to F13 to open menu
; Select action by: moving mouse toward it, or pressing number key (1-6)
; ============================================================================

F13::ShowWheelMenu()

; ============================================================================
; TELEGRAM MONITOR HOTKEY: Ctrl+F14
; ============================================================================
; Register address for Telegram monitoring of large transfers
; Hold Ctrl + click the button you mapped to F14
; ============================================================================

^F14::HandleTelegramRegister()

; ============================================================================
; DEFINED.FI LOOKUP HOTKEY: F15
; ============================================================================
; Open Solana token on defined.fi with automatic search
; Hover over token address + press F15
; Requires Tampermonkey UserScript for reliable search automation
; ============================================================================

F15::HandleDefinedFiLookup()

; ============================================================================
; TOKEN ANALYSIS HOTKEY: F16
; ============================================================================
; Analyze token for early bidders (requires monitor service + Helius API)
; Hover over token address + press F16
; Results available at http://localhost:5001/analysis
; ============================================================================

F16::HandleTokenAnalysis()

; ============================================================================
; Core Function: Capture text and open Solscan
; ============================================================================

HandleSolscanLookup() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Store this as the current main address and reset exclusions
            global currentMainAddress := address
            global excludedAddressesList := []

            OpenSolscan(address)
            ShowNotification("Opening Solscan...", address)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Core Function: Capture text and open Solscan WITH EXCLUDE FILTER
; ============================================================================

HandleSolscanLookupWithExclude() {
    ; IMPORTANT: Capture text FIRST before doing any navigation
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor (same as F14)
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; NOW get the current URL and parse both address and existing exclusions
    urlData := GetAddressAndExclusionsFromURL()
    currentAddress := urlData.address
    existingExclusions := urlData.exclusions

    ; Validate we're on a Solscan page
    if (currentAddress == "") {
        ShowNotification("No Solscan page detected", "Open a Solscan address page first")
        return
    }

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        addressToExclude := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (addressToExclude == "" && IsValidSolanaAddress(capturedText)) {
            addressToExclude := capturedText
        }

        ; Validate the address to exclude
        if (addressToExclude != "" && IsValidSolanaAddress(addressToExclude)) {
            ; Check if already excluded
            alreadyExcluded := false
            for index, addr in existingExclusions {
                if (addr == addressToExclude) {
                    alreadyExcluded := true
                    break
                }
            }

            if (!alreadyExcluded) {
                existingExclusions.Push(addressToExclude)
            }

            ; Reload the current page with updated exclusions
            ReloadPageWithExclusions(currentAddress, existingExclusions)
            ShowNotification("Excluded address added", addressToExclude)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Text Capture Logic
; ============================================================================

CaptureTextUnderCursor() {
    ; Strategy 1: Check if text is already selected
    Send "^c"
    if ClipWait(0.2) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; Strategy 2: Double-click to select word under cursor
    Click
    Sleep 50
    Click
    Sleep SELECTION_DELAY

    ; Copy selected text
    Send "^c"
    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            captured := Trim(A_Clipboard)
            return captured
        }
    }

    ; Strategy 3: Select entire line (fallback)
    Send "{Home}"
    Send "+{End}"
    Sleep SELECTION_DELAY
    Send "^c"
    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return A_Clipboard
        }
    }

    return ""
}

; ============================================================================
; Text Capture for Exclusion (Selection-Based Only)
; ============================================================================
; This function ONLY captures pre-selected text to avoid any mouse clicks
; User must manually select/highlight the address before pressing XButton1

CaptureTextWithoutClicking() {
    ; Only try to copy already-selected text
    ; No mouse clicking or automatic selection
    A_Clipboard := ""
    Send "^c"

    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; If nothing was selected, return empty
    ; User needs to manually select the address first
    return ""
}

; ============================================================================
; Validation: Solana Address Pattern
; ============================================================================

IsValidSolanaAddress(text) {
    ; Remove whitespace and quotes
    text := Trim(text)
    text := StrReplace(text, "`r", "")
    text := StrReplace(text, "`n", "")
    text := StrReplace(text, " ", "")
    text := StrReplace(text, '"', "")
    text := StrReplace(text, "'", "")

    ; Solana addresses are base58 encoded, 32-44 characters
    length := StrLen(text)
    if (length < 32 || length > 44) {
        return false
    }

    ; Check if all characters are valid base58 (excludes 0, O, I, l)
    Loop Parse, text
    {
        char := A_LoopField
        ; Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
        if !RegExMatch(char, "[1-9A-HJ-NP-Za-km-z]") {
            return false
        }
    }

    return true
}

; ============================================================================
; Helper: Extract address from longer text
; ============================================================================

ExtractAddressFromText(text) {
    ; Try to find a base58 string of correct length
    if RegExMatch(text, "[1-9A-HJ-NP-Za-km-z]{32,44}", &match) {
        return match[0]
    }
    return ""
}

; ============================================================================
; Helper: Get address and exclusions from current browser URL (Combined)
; ============================================================================
; IMPORTANT: This function depends on Solscan's URL structure
;
; URL Structure Dependencies (as of 2025):
; -----------------------------------------
; 1. Main address format:
;    https://solscan.io/account/{ADDRESS}?params...
;    Regex: "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})"
;
; 2. Exclusion parameter format:
;    &to_address=!Addr1,!Addr2,!Addr3
;    - Parameter name: "to_address"
;    - Exclusion prefix: "!" (exclamation mark)
;    - Separator: "," (comma)
;    - URL encoded: %21 for !, %2C for comma (case insensitive)
;    Regex: "to_address=([^&]+)"
;
; If Solscan changes their URL structure, update the following:
; - Line ~306: Main address regex pattern
; - Line ~312: Exclusion parameter name
; - Line ~316: Exclusion prefix character
; - Line ~319: Separator character
;
; Fallback behavior if parsing fails:
; - result.address will be "" (empty string)
; - result.exclusions will be [] (empty array)
; - Script will show "No Solscan page detected" notification
; ============================================================================

GetAddressAndExclusionsFromURL() {
    ; Get the current browser URL by copying it from the address bar
    ; Save clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Select address bar (Ctrl+L works in most browsers)
    Send "^l"
    Sleep 100

    ; Copy URL
    Send "^c"
    Sleep 100

    ; Get URL from clipboard
    currentURL := A_Clipboard

    ; Restore clipboard
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Press Escape to deselect address bar
    Send "{Escape}"

    ; Create result object
    result := {address: "", exclusions: []}

    ; Extract address from Solscan URL
    ; Format: https://solscan.io/account/ADDRESS...
    ; UPDATE THIS if Solscan changes their URL pattern
    if RegExMatch(currentURL, "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})", &match) {
        result.address := match[1]
    }

    ; Parse existing exclusions from to_address parameter
    ; Format: to_address=!Addr1,!Addr2 or to_address=%21Addr1,%21Addr2 or %21Addr1%2C%21Addr2
    ; UPDATE THIS if Solscan changes their parameter name or format
    if RegExMatch(currentURL, "to_address=([^&]+)", &match) {
        excludeParam := match[1]

        ; URL decode common characters
        ; UPDATE THIS if Solscan changes encoding
        excludeParam := StrReplace(excludeParam, "%21", "!")  ; ! (exclamation)
        excludeParam := StrReplace(excludeParam, "%2C", ",")  ; , (comma)
        excludeParam := StrReplace(excludeParam, "%2c", ",")  ; , (comma lowercase)

        ; Split by comma to get individual exclusions
        ; UPDATE THIS if Solscan changes separator
        Loop Parse, excludeParam, ","
        {
            address := A_LoopField
            ; Remove the ! prefix
            ; UPDATE THIS if Solscan changes exclusion prefix
            if (SubStr(address, 1, 1) == "!") {
                address := SubStr(address, 2)
            }
            ; Validate and add to list
            if (address != "" && IsValidSolanaAddress(address)) {
                result.exclusions.Push(address)
            }
        }
    }

    return result
}

; ============================================================================
; Action: Open Solscan in Browser
; ============================================================================

OpenSolscan(address) {
    ; Custom Solscan URL with your preferred filters
    url := "https://solscan.io/account/" . address . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value=&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"
    Run url
}

; ============================================================================
; Action: Reload Page with Exclusions (URL-Based, Per-Tab Persistence)
; ============================================================================
; IMPORTANT: This function builds Solscan URLs with exclusion filters
;
; If Solscan changes their URL structure, update the following:
; - Line ~400: Parameter name "to_address"
; - Line ~392: Exclusion prefix "!"
; - Line ~389: Separator character ","
; - Line ~397-403: Base URL and all other parameters
; ============================================================================

ReloadPageWithExclusions(mainAddress, exclusionsList) {
    ; Build the exclusion parameter from the list
    ; Format: to_address=!Address1,!Address2,!Address3
    ; UPDATE THIS if Solscan changes format
    excludeParam := ""

    for index, excludeAddr in exclusionsList {
        if (excludeAddr != "") {
            if (excludeParam != "") {
                excludeParam .= ","  ; UPDATE THIS if separator changes
            }
            excludeParam .= "!" . excludeAddr  ; UPDATE THIS if prefix changes
        }
    }

    ; Build URL with exclusion filter
    ; UPDATE THIS entire URL structure if Solscan redesigns
    ; IMPORTANT: Match parameter order from OpenSolscan() to avoid Solscan parsing issues
    url := "https://solscan.io/account/" . mainAddress . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value="

    ; Insert to_address BEFORE token_address (same as OpenSolscan)
    if (excludeParam != "") {
        url .= "&to_address=" . excludeParam  ; UPDATE THIS parameter name if changed
    }

    url .= "&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"

    ; Copy URL to clipboard
    A_Clipboard := url
    Sleep 100  ; Give clipboard time to update

    ; Focus browser and navigate to URL using address bar
    ; Ctrl+L selects address bar in most browsers
    Send "^l"
    Sleep 100
    ; Paste the URL
    Send "^v"
    Sleep 100
    ; Press Enter to navigate
    Send "{Enter}"
}

; ============================================================================
; Telegram Monitor: Register Address for Monitoring
; ============================================================================

HandleTelegramRegister() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and register for monitoring
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to local monitoring service
            RegisterAddressWithMonitor(address)
        } else {
            ShowNotification("Invalid address", "Cannot register for monitoring")
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

RegisterAddressWithMonitor(address) {
    ; Build JSON payload
    jsonData := '{"address":"' . address . '","timestamp":"' . A_Now . '"}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_register.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to local server
    command := 'curl -X POST "' . LOCAL_SERVER_URL . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ShowNotification("Monitoring registered", address)
        } else {
            ShowNotification("Monitor service offline", "Start Python service first")
        }
    } catch {
        ShowNotification("Monitor service offline", "Start Python service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; Defined.fi Lookup: Open Token on defined.fi with Auto-Search
; ============================================================================

HandleDefinedFiLookup() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open defined.fi
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Open defined.fi with hash parameter for UserScript to handle
            url := "https://defined.fi/#autosearch=" . address
            Run url
            ShowNotification("Opening defined.fi", address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

; ============================================================================
; Token Analysis: Analyze token for early bidders using Helius API
; ============================================================================

HandleTokenAnalysis() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and analyze
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to analysis service
            AnalyzeTokenWithService(address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

AnalyzeTokenWithService(tokenAddress) {
    ; Build JSON payload
    jsonData := '{"address":"' . tokenAddress . '","min_usd":50,"time_window_hours":24}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_analyze.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to analysis endpoint
    analysisUrl := "http://localhost:5001/analyze/token"
    command := 'curl -X POST "' . analysisUrl . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ShowNotification("Analysis queued", "View results at localhost:5001")
            ; Optionally open browser to results
            Run "http://localhost:5001/analysis"
        } else {
            ShowNotification("Analysis service offline", "Start monitor service first")
        }
    } catch {
        ShowNotification("Analysis service offline", "Start monitor service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; UI Feedback: Toast Notification
; ============================================================================

ShowNotification(title, message) {
    ToolTip title . "`n" . message
    SetTimer () => ToolTip(), -NOTIFICATION_DURATION
}

; ============================================================================
; RADIAL PIE MENU SYSTEM (GDI+)
; ============================================================================
; Beautiful Blender-style radial pie menu using GDI+ for native rendering
;
; INTERACTION METHODS:
; - Keyboard: Press 1-5 to select action, Esc/6 to cancel (PRIMARY METHOD)
; - Mouse: Click pie slices directly
;
; NOTE: Keyboard shortcuts via AutoHotkey (#HotIf) are the primary interaction
; ============================================================================

global WheelMenuActive := false
global WheelMenuGui := ""

ShowWheelMenu() {
    global WheelMenuActive, WheelMenuGui

    if (WheelMenuActive) {
        CloseWheelMenu()
        return
    }

    MouseGetPos &mx, &my

    size := 300
    centerX := size // 2
    centerY := size // 2
    radius := 130
    innerRadius := 50

    WheelMenuGui := Gui("-Caption +E0x80000 +E0x20 +AlwaysOnTop +ToolWindow")
    WheelMenuGui.Show("x" . (mx - centerX) . " y" . (my - centerY) . " w" . size . " h" . size . " NoActivate")
    hwnd := WheelMenuGui.Hwnd

    hbm := CreateDIBSection(size, size)
    if (!hbm) {
        WheelMenuGui.Destroy()
        WheelMenuGui := ""
        return
    }

    hdc := CreateCompatibleDC()
    if (!hdc) {
        DeleteObject(hbm)
        WheelMenuGui.Destroy()
        WheelMenuGui := ""
        return
    }

    hOldBitmap := SelectObject(hdc, hbm)
    pGraphics := Gdip_GraphicsFromHDC(hdc)
    if (!pGraphics) {
        SelectObject(hdc, hOldBitmap)
        DeleteDC(hdc)
        DeleteObject(hbm)
        WheelMenuGui.Destroy()
        WheelMenuGui := ""
        return
    }

    Gdip_SetSmoothingMode(pGraphics, 4)
    Gdip_GraphicsClear(pGraphics, 0x00000000)

    colors := [0xAA4A90E2, 0xAAE74C3C, 0xAA9B59B6, 0xAA2ECC71, 0xAAF39C12, 0xAA95A5A6]
    Loop colors.Length {
        startAngle := (A_Index - 1) * 60 - 90
        pBrush := Gdip_BrushCreateSolid(colors[A_Index])
        if (pBrush) {
            Gdip_FillPie(pGraphics, pBrush, centerX - radius, centerY - radius, radius * 2, radius * 2, startAngle, 60)
            Gdip_DeleteBrush(pBrush)
        }
    }

    pBrushCenter := Gdip_BrushCreateSolid(0xFF1E1E1E)
    if (pBrushCenter) {
        Gdip_FillEllipse(pGraphics, pBrushCenter, centerX - innerRadius, centerY - innerRadius, innerRadius * 2, innerRadius * 2)
        Gdip_DeleteBrush(pBrushCenter)
    }

    UpdateLayeredWindow(hwnd, hdc, mx - centerX, my - centerY, size, size)

    Gdip_DeleteGraphics(pGraphics)
    SelectObject(hdc, hOldBitmap)
    DeleteDC(hdc)
    DeleteObject(hbm)

    WheelMenuActive := true
}

SelectWheelAction(actionId) {
    ; Close menu first
    CloseWheelMenu()

    ; Small delay
    Sleep 50

    ; Execute action
    switch actionId {
        case 1: HandleSolscanLookup()
        case 2: HandleSolscanLookupWithExclude()
        case 3: HandleTelegramRegister()
        case 4: HandleDefinedFiLookup()
        case 5: HandleTokenAnalysis()
        case 6: return  ; Cancel - just close
    }
}

CloseWheelMenu() {
    global WheelMenuActive, WheelMenuGui

    if (!WheelMenuActive) {
        if (WheelMenuGui) {
            try WheelMenuGui.Destroy()
            WheelMenuGui := ""
        }
        return
    }

    WheelMenuActive := false

    if (WheelMenuGui) {
        try WheelMenuGui.Destroy()
        WheelMenuGui := ""
    }
}

; Conditional hotkeys - only active when menu is open
#HotIf WheelMenuActive
1::SelectWheelAction(1)
2::SelectWheelAction(2)
3::SelectWheelAction(3)
4::SelectWheelAction(4)
5::SelectWheelAction(5)
Escape::CloseWheelMenu()
#HotIf

; ============================================================================
; Exit Hotkey: Ctrl+Alt+Q to quit script
; ============================================================================

^!q:: {
    result := MsgBox("Are you sure you want to exit?", "Exit Solscan Hotkey", "YesNo")
    if (result = "Yes") {
        ExitApp
    }
}

; ============================================================================
; Tray Menu Customization
; ============================================================================

A_TrayMenu.Delete()
A_TrayMenu.Add("Reload Script", (*) => Reload())
A_TrayMenu.Add("Exit", (*) => ExitApp())
A_IconTip := "Solscan Hotkey Active`nF13: Wheel Menu (all actions)`nF14: Open address`nF15: Defined.fi lookup`nF16: Analyze token`nCtrl+F14: Monitor address"
